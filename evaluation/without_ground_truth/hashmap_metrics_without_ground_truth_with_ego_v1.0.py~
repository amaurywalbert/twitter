# -*- coding: latin1 -*-
################################################################################################
import datetime, sys, time, json, os, os.path, shutil, time, struct, random
import subprocess


reload(sys)
sys.setdefaultencoding('utf-8')

######################################################################################################################################################################
######################################################################################################################################################################
##		Status - Versão 1 - Calcular métricas principais métricas para avaliação sem ground truth de acordo com
## 
##			SALVA ARQUIVOS NOS DIRETÒRIOS:
##				RAW: conforme calculado - 
##				SEPARATE BY METRICS
## 							
## # INPUT: Arquivos com as comunidades detectadas, rede e o ground truth
## 
## # OUTPUT:
##			Resultados separados por métrica
######################################################################################################################################################################

######################################################################################################################################################################
#
# Prepara arquivos para ficar no mesmo formato  que a versão anterior - separados por METRICA
#
######################################################################################################################################################################
def by_metrics(alg,singletons):
	
	data_dir = str(output)+"raw/"+str(g_type)+"/"+str(alg)+"/"+str(singletons)+"/"
	
	if not os.path.isdir(data_dir):
		print ("\n\n\nDIRETÓRIO NÃO ENCONTRADO: "+str(data_dir)+"\n\n\n")
		
	else:
		for net in os.listdir(data_dir):
			if os.path.isdir(data_dir+net):
				print ("\n##################################################")
				print ("Separando por métrica - Recuperando dados da rede "+str(net)+" - "+str(data_dir)+"\n")
			
				for file in os.listdir(data_dir+net):	
					threshold = file.split(".json")											# pegar o nome do arquivo que indica o a rede analisada
					threshold = threshold[0]
				
					with open(data_dir+net+"/"+file, 'r') as f:
						data = json.load(f)
						for k, v in data.iteritems():											# Preparação para ler o arquivo JSON que tem o Formato  {metric": [values ---- {"VI": [0.542,...], "NMI": [0,214,0,36...],...}
							dictionary = {}
							values = v
							metric = k

							dictionary[threshold] = values
							print ("Salvando dados em: "+str(output)+str(metric)+"/"+str(g_type)+"/"+str(alg)+"/"+str(singletons)+"/" +str(net)+".json")
	
							if not os.path.isdir(output_dir+str(metric)+"/"):
								os.makedirs(output_dir+str(metric)+"/")			
								
							with open(output_dir+str(metric)+"/"+str(net)+".json", "a+") as f:
								f.write(json.dumps(dictionary, separators=(',', ':'))+"\n")

	print ("##################################################")	

######################################################################################################################################################################
#
# Cálculos iniciais sobre o conjunto de dados lidos.
#
######################################################################################################################################################################
def calculate_alg(communities,output,singletons,net,graphs,uw,ud,g_type):
	
	communities = communities+singletons+"/"+net+"/"
	output = output+singletons+"/"+net+"/"
	if not os.path.exists(output):
		os.makedirs(output)
	print	
	print("######################################################################")
	print ("Os arquivos serão armazenados em: "+str(output))
	print("######################################################################")

	for threshold in range(51):	#Parâmetro do algoritmo de detecção
		threshold+=1
		i=0 		#Ponteiro para o ego

		if not os.path.isdir(str(communities)+str(threshold)+"/"):
			print ("Diretório com as comunidades não encontrado: "+str(communities)+str(threshold))

		else:	
			if os.path.isfile(str(output)+str(threshold)+".json"):
				print ("Arquivo de destino já existe: "+str(output)+str(threshold)+".json")
			else:	
				print("######################################################################")
				result = {}					
				modularity = []
				modularity_density = []
				intra_edges = []
				intra_density = []
				contraction = []
				inter_edges = []
				expansion = []
				conductance = []

				for file in os.listdir(str(communities)+str(threshold)+"/"):
					ego_id = file.split(".txt")
					ego_id = long(ego_id[0])
					i+=1

					if not os.path.isfile(str(graphs)+str(ego_id)+".edge_list"):
						print ("ERROR - EGO: "+str(i)+" - Arquivo com lista de arestas não encontrado:" +str(graphs)+str(ego_id)+".edge_list")

					else:	
						execute = subprocess.Popen(["/home/amaury/algoritmos/Metricas/ParallelComMetric-master/src/pthreadmetric","4","0",str(communities)+str(threshold)+"/"+str(file),str(graphs)+str(ego_id)+".edge_list",str(uw),str(ud)], stdout=subprocess.PIPE)
							
						value = execute.communicate()[0]
						b = value.split('\n')							
						t = b[0].split('\t')
						a = b[1].split('\t')

						print (str(g_type)+" - "+str(singletons)+" - Rede: "+str(net)+" - THRESHOLD: "+str(threshold)+" - ego("+str(i)+"): "+str(file)+" - "+str(a))
							
						modularity.append(float(a[1]))
						modularity_density.append(float(a[2]))
						intra_edges.append(float(a[3]))
						intra_density.append(float(a[4]))
						contraction.append(float(a[5]))
						inter_edges.append(float(a[6]))
						expansion.append(float(a[7]))
						conductance.append(float(a[8]))


				print("######################################################################")
				result['modularity'] = modularity
				result['modularity_density'] = modularity_density
				result['intra_edges'] = intra_edges
				result['intra_density'] = intra_density
				result['contraction'] = contraction
				result['inter_edges'] = inter_edges
				result['expansion'] = expansion
				result['conductance'] = conductance	


				with open(str(output)+str(threshold)+".json", 'w') as f:
					f.write(json.dumps(result))

	print("######################################################################")		

######################################################################################################################################################################
#
# Método principal do programa.
# Realiza teste e coleta dos dados de cada user especificado no arquivo. 
#
######################################################################################################################################################################
######################################################################################################################################################################
def main():
	os.system('clear')
	print "################################################################################"
	print"																											"
	print" 			Avaliação de Comunidades - Chen's Software										"
	print"																											"
	print"#################################################################################"
	print
	print"Realizar o cálculo usando Singletons?"
	print 
	print" 01 - SIM - full"
	print" 02 - NÃO"
	print
	op = int(raw_input("Escolha uma opção acima: "))
	if op == 01:
		singletons = "full"
	elif op == 02:
		singletons = "without_singletons"
	else:
		singletons = ""
		print("Opção inválida! Saindo...")
		sys.exit()	
#######################################################################
#######################################################################
	print("######################################################################")	
	print
	print "Algoritmo utilizado na detecção das comunidades"
	print 
	print" 01 - COPRA"
	print" 02 - OSLOM"
	print
	op2 = int(raw_input("Escolha uma opção acima: "))
	if op2 == 01:
		alg = "copra"
	elif op2 == 02:
		alg = "oslom"	
	else:
		alg = ""
		print("Opção inválida! Saindo...")
		sys.exit()	
	print
	print
	print ("Opção escolhida: "+str(singletons)+" - "+str(alg))
	print ("Aguarde...")
	time.sleep(5)
	######################################################################################################################
	#####Alterar as linhas para Dropbox quando executado em ambiente de produção
	communities = "/home/amaury/communities_hashmap/"+str(g_type)+"/"+str(alg)+"/" 
	output_raw = str(output)+"/raw/"+str(g_type)+"/"+str(alg)+"/"

	for i in range(10):								# Para cada rede-ego gerada
		i+=1
		if i == 1 or i == 9:
			uw=1											# Rede não ponderada - unweighted
		else:
			uw=0
		if i in (5,6,7,8,10):
			ud=1											# Rede não direcionada - undirected
		else:
			ud=0	 
		net = "n"+str(i)
		graphs = "/home/amaury/graphs_hashmap/"+str(net)+"/"+str(g_type)+"/"

		print
		print ("Calculando métricas nas comunidades detectadas na rede: "+str(net)+" - COM o ego - Algoritmo: "+str(alg))

		calculate_alg(communities,output_raw,singletons,net,graphs,uw,ud,g_type)
	
	######################################################################################################################
		
	# Separa por Métricas...

	by_metrics(alg,singletons)

	######################################################################################################################

	print("######################################################################")
	print
	print("######################################################################")
	print("Script finalizado!")
	print("######################################################################\n")

	
######################################################################################################################################################################
#
# INÍCIO DO PROGRAMA
#
######################################################################################################################################################################
g_type = "graphs_with_ego"	
output = "/home/amaury/Dropbox/evaluation_hashmap/without_ground_truth/"
######################################################################################################################
if __name__ == "__main__": main()
